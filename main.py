import tkinter as tk
import re
import urllib.request, urllib.parse, urllib.error
from headerURL import *
from scanner import *
from tkinter import *
from tkinter import ttk
from tkinter.messagebox import showinfo
from tkinter import filedialog


class MainWindow:
	'''
	Main class that contains the interface of the program and important functions
	'''

	def __init__(self, master):
		self.master = master
		self.master.geometry("870x750")
		self.master.resizable(False, False)
		self.master.title("Final Year Project")
		self.master.configure(background = "cornflowerblue")
		self.img_logo = PhotoImage(file = "UoG_logo.png")
		self.label_logo = Label(image = self.img_logo, bg = "cornflowerblue")
		self.label_logo.place(relx=0.1, rely=0.05, anchor="center")
		
		#set title label
		self.label_title = tk.Label(text="Vulnerability & Privacy Scanner", background="cornflowerblue", fg="white",
                                   font=("Georgia", "30", "bold", "italic"))
		self.label_title.place(relx=0.5, rely=0.12, anchor="center")
		
		#label enter ULR
		self.label_enterURL = tk.Label(text="Enter the URL you want to scan for Vulnerabilities", background="cornflowerblue", fg="white",
                                   font=("Georgia", "10", "italic"))
		self.label_enterURL.place(relx=0.2, rely=0.20, anchor="center")
		
		#set textbox for the url
		self.text_url = tk.Text(height = 1, width = 80)
		self.text_url.place(relx=0.39, rely=0.24, anchor="center")
		
		#button enter
		self.button_enter = tk.Button(text="Enter", font=("Georgia", "12", "bold"), height="0", width=8,
                                     background="lightsteelblue", foreground="black", bd="4", relief="raised",
                                     command=lambda: self.enter_url())
		self.button_enter.place(relx=0.40, rely=0.30, anchor="center")
		
		#set the button browse
		self.button_enter2 = tk.Button(text="Browse", font=("Georgia", "12", "bold"), height="0", width=8,
                                     background="lightsteelblue", foreground="black", bd="4", relief="raised",
                                     command=lambda: self.askopenfile())
		self.button_enter2.place(relx=0.88, rely=0.24, anchor="center")
		
		
		#set text main text box
		self.text_main = tk.Text(height = 28, width = 104)
		self.text_main.place(relx=0.50, rely=0.66, anchor="center")
		
		#set quit button
		self.button_exit = tk.Button(text="Exit", font=("Georgia", "12", "bold"), height="0", width=8,
                                     background="lightsteelblue", foreground="black", bd="4", relief="raised",
                                     command=root.destroy)
		self.button_exit.place(relx=0.88, rely=0.30, anchor="center")
		
		#set clear button
		self.button_clear = tk.Button(text="Clear", font=("Georgia", "9", "bold"), height="0", width=5,
                                     background="lightsteelblue", foreground="black", bd="4", relief="raised",
                                     command=lambda: self.text_main.delete('1.0', END))
		self.button_clear.place(relx=0.06, rely=0.31, anchor="center")
		
		
	def enter_url(self):
		'''
		Function in response of the Button Enter that takes the URL as input
		'''
		
		input_url = self.text_url.get("1.0", 'end-1c')
		if "?" in input_url:
			header_reader(input_url)
			remote_code_execution(input_url)
			cross_site_scripting(input_url)
			error_based_sql_injection(input_url)
		else:
			open('result.txt', 'w').close()
			showinfo("Alert Message", "You must write a Full URL e.g http://website.com/page.php?id=value")
			self.text_url.delete('1.0', END)
			
		result = open("result.txt", "r")
		data = result.read()
		self.text_main.insert(END, data)
		result.close
			
	def askopenfile(self):
		'''
		Function in response of the button Browse that elaborate the file selected
		'''
		Keyword = ["document.location", "document.cookie", "/redirect", "c4fbb68607bcbb25407e0362dab0b2ea", "whoami", ";phpinfo"]
		filename =  filedialog.askopenfile(initialdir = "/Desktop/", title = "Select file",filetypes = (("text files","*.txt"),("all files","*.*")))
		
		try:
			data_result = []
			read_data = filename.readlines()
			# loop for each element of the list
			for key in Keyword:
				counter_line = 0
				# loop that reads line by line the file text
				for line in read_data:
					counter_line += 1
					# condition if a keyword is found on the line 
					if key in line:
						self.text_main.insert(END, "-------------------------------------------\n")
						print(col.red +"\n [!] WARNING: Match on the line %i : \n" % counter_line + line + col.end)
						self.text_main.insert(END, "\n [!] WARNING: Match on the line %i : \n" % counter_line + line)
						self.type_of_case(key)
		except:
			pass
		
	def type_of_case(self, key):
		'''
		Function that contain the information about the malicious code found 
	
		'''
		Keyword_dict = {"document.location": " [~] Description: \n The Document.location read-only property returns a Location object, which contains information about the URL of the document and provides methods for changing that URL and loading another URL.\n",
		 "document.cookie": " [~] Description: \n In the code above document.cookies contain a semicolon-separated list of all cookies (i.e. key=value pairs). Note that each key and value may be surrounded by whitespace (space and tab characters): in fact, RFC 6265 mandates a single space after each semicolon, but some user agents may not abide by this. When user privacy is a concern, it's important that any web app implementation invalidate cookie data after a certain timeout instead of relying on the browser to do it. Many browsers let users specify that cookies should never expire, which is not necessarily safe.\n",
		  "/redirect": " [~] Description: \n Malicious redirects are caused by hackers injecting scripts into infected sites that send visitors to destinations where they usually get scammed or infected with malware.\n",
		   "c4fbb68607bcbb25407e0362dab0b2ea": " [~] Description: \n Md5 hash used as backdoor installed on the computer that sent commands in response to which it performs certain actions. These can be commands aimed at extracting valuable information from the system, such as environmental variables, or designed to perform an attack on the database. To get more information about the attacker you need to look into the access log of your server. You might find requests to your site with a path like this:/compromised.php?p=<password>&s=<command>\n",
		    "whoami": " [~] Description: \n It is basically the concatenation of the strings “who”,”am”,”i” as whoami. It displays information such as username of the current user that can be used for maliciuos reasons.\n",
		     ";phpinfo": " [~] Description: \n  When the attacker can assign another value to the variable, he will be able to create a new command by using a semicolon (;). He can now fill in the rest f the string. This way, he will not get any syntax errors in his work. As soon as he executes this code, the output of phpinfo would be displayed on the page. \n"}
		
		#Condition if to print the details if any malicious code was found
		if key in Keyword_dict:
			print(Keyword_dict[key])
			self.text_main.insert(END, Keyword_dict[key])
			


if __name__== '__main__':
	root = tk.Tk()
	app = MainWindow(root)
	root.mainloop()
